<!--
title: Powershell
description: 
published: true
date: 2021-05-24T10:36:53.480Z
tags: 
editor: ckeditor
dateCreated: 2021-05-24T10:36:52.011Z
-->

<h1>Définition</h1>
<p>PowerShell est un langage script, open source, fondé sur la programmation orientée objet et qui s'appuie sur le Framework .net core (une bibliothèque de fonctionnalités multiplateforme). Le logiciel PowerShell &nbsp;est l'interpréteur de l’interface en ligne de commande de l'environnement de développement Windows PowerShell. Ces fonctionnalités principales sont d'administrer des systèmes, d'automatiser des tâches et de développer des outils .</p>
<p>&nbsp;</p>
<h2>Le Langage objet</h2>
<p>PowerShell est un langage orienté “objet” . C'est à dire que PowerShell considère tout les éléments qu'il traite ainsi. Pour vous expliquez cela, je vais prendre comme exemple une voiture. Une voiture a des propriétés comme sa couleur, sa forme, sa taille etc.. les propriétés d'un objet s'apparentent plutôt à des éléments physiques, ses méthodes seraient donc rouler, tourner, avancer, reculer etc… les méthodes sont davantage liées à une action.</p>
<p>Pour être concret, un service a comme propriétés son nom, son statuts et comme méthodes démarrer, arrêter, en attente etc…et bien PowerShell fonctionne ainsi.</p>
<p>on verra plus tard comment lister tout ces éléments et savoir si nous sommes devant une propriété ou une méthode.</p>
<p>&nbsp;</p>
<h2>Installation</h2>
<p>&nbsp;</p>
<p>Si PowerShell n'est pas installé sur votre machine je vous invite à vous rendre sur le GitHub de PowerShell via ce <a href="https://github.com/PowerShell/PowerShell/releases">lien</a> et de télécharger la dernière version core stable (7.1.3 à ce jour) sur votre système.&nbsp;</p>
<p>Si vous êtes sous Windows, il y a également la possibilité de le télécharger par le biais du Windows store.</p>
<p>Pour les prérequis de Windows PowerShell, je vous invite à suivre ce <a href="https://docs.microsoft.com/fr-fr/powershell/scripting/windows-powershell/install/windows-powershell-system-requirements?view=powershell-7.1">lien.</a></p>
<p>Lors de l'installation vous pouvez laisser tout les paramètres d'installation par défaut.</p>
<p>Si vous êtes sous linux je vous invite à suivre ce <a href="https://docs.microsoft.com/fr-fr/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7.1">lien</a> pour l'installation de PowerShell sur ce système.</p>
<p>Si vous êtes sur Mac, tout se trouve <a href="https://docs.microsoft.com/fr-fr/powershell/scripting/install/installing-powershell-core-on-macos?view=powershell-7.1">ici.</a></p>
<p>Et pour l'utilisation de PowerShell sous docker, c'est par <a href="https://docs.microsoft.com/fr-fr/powershell/scripting/install/powershell-in-docker?view=powershell-7.1">ici</a>.</p>
<p>Windows ne met plus à jour la version Windows PowerShell (en version 5.1 à ce jour) pour au final passer à la version core car celle-ci est multiplateforme.</p>
<p>&nbsp;</p>
<h2>La console PowerShell</h2>
<p>&nbsp;</p>
<p>Pour lancer PowerShell il faut utiliser l'exécutable <code>PWSH</code>. Pour cela, appuyer simultanément sur la touche <strong>Windows + R, </strong>puis tapez<code> PWSH</code>.&nbsp;</p>
<p>La console PowerShell peut être lancée en exécutant une commande en même temps:</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext"> PWSH  -command &lt;une commande&gt;</code></pre>
<p>&nbsp;</p>
<p>On peut aussi lancer cette même commande sans que la console se referme avec&nbsp;</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">PWSH -noexit -command &lt;une commande&gt;</code></pre>
<p>&nbsp;</p>
<p>On peut également connaitre sa version de PowerShell en le spécifiant avec le paramètre <code>-version</code>.&nbsp;</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">PWSH -version</code></pre>
<p>&nbsp;</p>
<p>Pour terminer, on peut lancer la console en spécifiant directement à l'endroit ou l'on souhaite se positionner avec le paramètre <code>-WorkingDirectory</code>.</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">PWSH -WorkingDirectory c:\windows</code></pre>
<p>&nbsp;</p>
<p>Il existe encore d'autres paramètres que vous pouvez obtenir en tapant:</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">PWSH /?</code></pre>
<p>&nbsp;</p>
<p>Si vous désirez utiliser la console Windows PowerShell (en version 5.1 à ce jour), il vous suffira d'exécuter la commande <code>PowerShell</code>. Vous pouvez constater que les deux versions peuvent cohabiter. A termes, Windows &nbsp;fournira uniquement la version core de PowerShell puisque celle-ci est multiplateforme et Windows PowerShell ne bénéficie plus de mises à jour.&nbsp;</p>
<h2>Configuration de la console</h2>
<p>&nbsp;</p>
<p>Pour configurer votre console cliquez sur l'icône en haut à gauche puis de sélectionner Propriétés.</p>
<figure class="image"><img src="/console.png"></figure>
<p>&nbsp;</p>
<p>Dans le menu propriétés, vous avez la possibilité de paramétrer votre terminal PowerShell à votre guise. Tel que la couleur de la console, l'opacité, la taille du texte, la police, la forme du curseur etc…</p>
<figure class="image"><img src="/console3.png"></figure>
<p>&nbsp;</p>
<h2>Rechercher dans la console</h2>
<p>&nbsp;</p>
<p>Pour rechercher dans la console PowerShell vous pouvez utiliser &nbsp;le menu de la console PowerShell.&nbsp;</p>
<figure class="image"><img src="/recherche.png"></figure>
<p>&nbsp;</p>
<p>Il suffit ensuite de taper un mot et de cliquer sur <code>suivant</code> pour que ce mot soit surligner dans la console PowerShell. Cliquez de nouveau sur <code>suivant</code> pour atteindre le prochain.</p>
<figure class="image"><img src="/recherche2.png"></figure>
<p>&nbsp;</p>
<h2>Les raccourcis clavier</h2>
<p>&nbsp;</p>
<p>Avant de se lancer tête baissée, dans PowerShell, deux raccourcis clavier sont indispensables dans le sens où il vont vous permettre d'obtenir de l'aide et de gagner du temps.</p>
<ol>
  <li><strong><u>tabulation:</u></strong> vous permet de faire de la complétion, c'est à dire compléter le mot que vous êtes en train d'écrire.</li>
  <li><strong><u>ctrl + espace:</u></strong> lorsque vous souhaitez connaitre toutes les options d'une commande PowerShell, via ce raccourci, une liste de toutes les options possibles d'une commande vous sera suggérées voir même vous afficher des éléments pour compléter cette même option.</li>
</ol>
<figure class="image"><img src="/controle-espa.png"></figure>
<p>&nbsp;</p>
<p>alors, à consommer sans modération.</p>
<p>allez hop c'est parti….</p>
<p>&nbsp;</p>
<h2>Les commandes ou applets de commande (cmdlet)</h2>
<p>Elles sont composées d’une paire de la forme “verbe ”-“nom” destiné à en faciliter la mémorisation.</p>
<p>exemple :</p>
<pre><code class="language-plaintext">Get-Service</code></pre>
<p>get = verbe</p>
<p>service = nom</p>
<p>elles peuvent être accompagnées dans certains cas de paramètres et de valeurs. Par exemple avec la commande:</p>
<pre><code class="language-plaintext">New-Item -type file -Path c:\test.txt</code></pre>
<p>New-Item = la commande</p>
<p>-type = un paramètre</p>
<p>file = une valeur</p>
<p>-Path = un paramètre</p>
<p>c:\test.txt = une valeur</p>
<p>petite astuce, vous pouvez lister tout les verbes que PowerShell utilise avec la commande <code>Get-verb</code>. faites un essai…</p>
<p>simple non?</p>
<p>&nbsp;</p>
<h2>Le pipeline</h2>
<p>Le pipeline, symbolisée par le caractère “<strong>|</strong>” (<strong>AltGr</strong> + <strong>6</strong>) permet d'exécuter plusieurs commandes à la suite.</p>
<p>Exemple :&nbsp;</p>
<pre><code class="language-plaintext">Get-Process | Sort-Object CPU</code></pre>
<p>Dans ce cas précis, la commande <code>Sort-Object</code> tri les processus par utilisation de Cpu</p>
<p>&nbsp;</p>
<h2>L' aide</h2>
<p>Sous PowerShell la commande <code>Get-Help</code> permet d'afficher la fonction et des exemples d'une commande.</p>
<pre><code class="language-plaintext">Get-Help  &lt;la commande&gt;</code></pre>
<p>&nbsp;</p>
<p>Mais avant d'utiliser cette commande il faut faire une mise à jour de l'aide de PowerShell avec la commande</p>
<pre><code class="language-plaintext"> Update-Help</code></pre>
<p>&nbsp;</p>
<p>Cette commande <code>Get-Help</code> permet d'avoir une aide de manière très générale si on souhaite obtenir plus d'informations on peut ajouter l'option <code>-detailed</code></p>
<pre><code class="language-plaintext">Get-Help &lt;la commande&gt; -detailed</code></pre>
<p>&nbsp;</p>
<p>On peut aussi lister des exemples d'utilisation d'une commande avec l'option <code>-examples</code></p>
<pre><code class="language-plaintext">Get-Help &lt;la commande&gt; -examples</code></pre>
<p>&nbsp;</p>
<p>Une dernière option de <code>Get-help</code> vous permet d'afficher l'aide complète de la commande <code>-Full</code></p>
<pre><code class="language-plaintext">Get-Help &lt;la commande&gt; -Full</code></pre>
<p>Il arrive parfois que l'aide renvoyée sous PowerShell ne soit pas complète malgré un <code>Update-Help.</code></p>
<p>Pour cela il y a possibilité d'aller consulter directement l'aide en ligne avec l'option <code>-online</code>&nbsp;</p>
<pre><code class="language-plaintext">Get-Help &lt;la commande&gt; -online</code></pre>
<p>&nbsp;</p>
<p>Si vous voulez de l'aide sur la syntaxe d'une commande, PowerShell indique par “<strong>[ ]</strong>” si le paramètre est obligatoire.</p>
<p>Par exemple si vous voulez de l'aide sur la syntaxe de commande <code>Get-ChildItem</code>&nbsp;</p>
<pre><code class="language-plaintext">Get-Help Get-ChildItem</code></pre>
<p>On peut constater dans la capture que certains paramètres sont obligatoires. Vous pouvez également voir tout en bas les liens connexes à cette commande.</p>
<figure class="image image_resized" style="width:88.82%;"><img src="/capture4.png"></figure>
<p>&nbsp;</p>
<p>La commande <code>Get-Help</code> permet également de rechercher une commande si, par exemple, vous souhaitez trouver une commande qui gère les services.</p>
<pre><code class="language-plaintext">Get-Help service</code></pre>
<p>Voici ce que renvoie la commande, on peut voir les commandes qui contiennent le mot service.</p>
<figure class="image image_resized" style="width:86.32%;"><img src="/capture1.png"></figure>
<p>&nbsp;</p>
<p>Une autre fonction de l'aide permet d'avoir des informations sur un sujet précis.</p>
<p>Pour lister ces sujets utilisez l'option <code>about_*</code>&nbsp;</p>
<pre><code class="language-plaintext">Get-Help about_*</code></pre>
<p>Par exemple, si vous voulez de l'aide au sujet de pipeline</p>
<pre><code class="language-plaintext">Get-Help about_pipeline</code></pre>
<p>Voici ce que renvoie la commande</p>
<figure class="image image_resized" style="width:84.46%;"><img src="/capture3.png"></figure>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Lister les méthodes et les propriétés</h2>
<p>Maintenant que nous avons vu, comment était composée une commande, le pipeline et l'aide, il est temps, comme je vous l'ai dis dans le premier chapitre, que tout était objet dans PowerShell et de découvrir plus en détail ce que sont les propriétés les méthodes. C'est à cet instant, que nous alors voir quelle commande va nous permettre de lister tout cela.</p>
<p><code>Get-Member</code> est la commande qui nous dis quels sont les propriétés et les méthodes que nous pouvons appliquer à un objet.</p>
<p>un exemple concret est plus parlant:</p>
<figure class="image"><img src="/get-member.png"></figure>
<p>(Vous remarquerez que j'utilise la commande <code>Get-Service</code>, que je récupère toutes les méthodes et propriétés en passant par une seconde commande <code>Get-Member</code> et pour enchainer ces commandes j'opte pour un pipeline)</p>
<p>C'est à partir de ces éléments qu'à présent on peut savoir quelles sont les propriétés et les méthodes d'un service.&nbsp;</p>
<p>Par exemple: Pause, Stop, Refresh sont des méthodes. Displayname, Servicename, ServiceType sont des propriétés.</p>
<p>&nbsp;</p>
<h2>Les providers</h2>
<p>Dans PowerShell, &nbsp;les providers permettent d'accéder par exemple à la base de registre, aux fichiers système, à l'environnement etc…</p>
<ul>
  <li>Base de Registre {HKLM, HKCU}</li>
  <li>Alias {alias}</li>
  <li>Environnement {env}</li>
  <li>FileSystem {C,D,E,F}</li>
  <li>Function {Function}</li>
  <li>variable {Variable}</li>
</ul>
<p>Pour lister l'ensemble des providers, on utilise la commande</p>
<pre><code class="language-plaintext">Get-Psdrive</code></pre>
<p>L'avantage c'est que vous pouvez parcourir ces éléments comme si c'était un système de fichiers.</p>
<p>Exemple, si vous voulez parcourir la base de registre machine &nbsp;il suffit de taper <code>cd hklm :</code> et vous vous retrouvez dans la base de registre et la parcourir comme si c'était un filesystem et revenir dans votre arborescence Windows avec un <code>cd c:</code>.</p>
<figure class="image"><img src="/capture9.png"></figure>
<p>Vous avez ensuite la possibilité de créer ou de consulter des entrées dans la base de registre comme si c'était un filesystem et utiliser les commandes de base.</p>
<p>Exemple avec la commande <code>Get-ChildItem</code> ,vous pouvez consulter toute la base de registre de votre hkey local machine</p>
<figure class="image image_resized" style="width:74.13%;"><img src="/capture6.png"></figure>
<p>&nbsp;</p>
<p>Pour modifier la valeur d'une clé de registre ou des propriétés d'un élément je vous laisse consulter la commande</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Set-ItemProperty </code></pre>
<h2>Récupérer des informations WMI et CIM</h2>
<p>Wmi (Windows Management instrumentation),implémenté dans Windows, permet d'obtenir des informations sur un système et même à distance tel que la version du bios, le nom de la machine, le fabricant, le modèle, la date d'installation etc. Cela permet en quelques sortes d'interroger l'inventaire matériel et logiciel de votre système.&nbsp;</p>
<p>Il existe deux commandes pour obtenir ces informations, mais on peut également invoquer des méthodes et des propriétés avec celle-ci, par exemple redémarrer un service, demander des infos sur vos disques et je vais vous montrez les différences qu'il peut exister.&nbsp;</p>
<p>Pour finir je vous montrerai une astuce pour “fouiner” dans la liste des requêtes WMI et Des instances CIM.</p>
<ol>
  <li><code><u>Get-WmiObject</u></code>: À partir de PowerShell 3.0, cette applet de commande a été remplacée par <code>Get-CimInstance</code>. Elle n'est plus mise à jour sous PowerShell. Elle se base sur des requêtes WMI et le protocole RPC (Remote Procedure Call).</li>
  <li><code><u>Get-CimInstance</u></code>: cette commande, se base sur des instances CIM (Common Information Model ) , WS-MAN (WS-Management) et le protocole WInRM (<i>Windows Remote Management), couplé au protocole SOAP (Simple Object Acces Protocol).</i></li>
</ol>
<p>Par conséquent, je vous conseille vivement d'utiliser le plus souvent possible <code>Get-CimInstance</code>, il y a encore tout un tas de raisons de l'utiliser mais je ne vais pas m'attarder la dessus, ce n'est pas le but.</p>
<p>Voyons comment utiliser ces commandes et obtenir des infos sur un système.</p>
<p>Récupérons les information sur la mémoire vive.</p>
<figure class="image"><img src="/get-ciminstance.png"></figure>
<p>&nbsp;</p>
<p>Vous remarquez que j'utilise l'option <code>-classname</code> ? et oui, en effet, toutes les requêtes WMI et les instances CIM sont regroupées par classe. Et c'est maintenant, que je vous montre comment je fais pour m'y retrouver dans toutes ces classes.</p>
<p>C'est alors que nous vient en aide la commande <code>Get-Cimclass</code>.</p>
<p>Si on exécute cette commande on voit que la liste est longue et que cela peut paraitre un peu compliqué, à première vue, et par forcément facile à lire. De plus, la commande renvoie l'ensemble des classes Wmi et Cim.</p>
<p>&nbsp;Pour cela 3 solutions pour s'y retrouver:</p>
<ul>
  <li><u>renvoyer le tout dans un fichier texte,</u> le sauvegarder pour l'avoir sous la main puis un petit “<strong>ctrl + F”</strong> pour rechercher dans la liste.</li>
</ul>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-CimClass | Out-File -path c:\classcim.txt</code></pre>
<p>&nbsp;</p>
<ul>
  <li><u>renvoyer le tout dans un fichier Excel</u> et faire sa petite recherche à l'aide d'outils incorporés.</li>
</ul>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-Cimclass | Select-Object CimClassName | Export-Csv -Path C:\classescim.csv</code></pre>
<p>&nbsp;</p>
<p>Petite remarque: <code>Select-Object</code> permet de filtrer les informations de la commande en récupérant uniquement la partie CimclassName de <code>Get-CimClass</code></p>
<p>&nbsp;</p>
<ul>
  <li><u>renvoyer le tout dans un GridView</u>, un outil, bien utile, fourni dans PowerShell .</li>
</ul>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-Cimclass | Out-GridView</code></pre>
<p>&nbsp;</p>
<p>J'en profite pour vous montrer le Gridview. &nbsp;</p>
<figure class="image"><img src="/gridview.png"></figure>
<p>&nbsp;</p>
<p>C'est une Fenêtre, bien pratique, qui permet dans ce cas, de mettre directement sous forme de tableau, de filtrer ou de rechercher des éléments renvoyés par une commande.</p>
<p>Vous commencez certainement à vous dire POWAAA!! &nbsp;puissant le truc…</p>
<p>Connaitre à quoi servent toutes les requêtes WMI et les instances CIM serait un peu fou. C'est pourquoi, je vous renvoie vers ce <a href="https://docs.microsoft.com/fr-fr/windows/win32/cimwin32prov/cimwin32-wmi-providers">lien</a> pour en connaitre leurs utilités et en savoir un peu plus sur ces classes.</p>
<p>Allez à vous de jouer! Essayez de récupérer des infos, comme par exemple sur la version de votre bios, la date de l'installation du système, le ou les disque(s) dur etc…</p>
<h2>Les variables</h2>
<p>Une variable PowerShell est un emplacement de stockage provisoire en mémoire destiné à recueillir une valeur, un objet ou une collection d’objets.<br>Les variables sont généralement nommées, et leurs noms sont toujours précédés d’un symbole “$“<br>Les variables sont automatiquement “typées” lors de l’affectation de valeur (si elles ne sont pas déclarées au préalable.)</p>
<p>Exemple :</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">$variable = une valeur </code></pre>
<p>&nbsp;</p>
<p>Avant de rentrer dans le vif de ce sujet, il faut savoir que sous PowerShell, il existe deux type de variables spécifiques générées automatiquement.</p>
<p>&nbsp;</p>
<h3>Les variables automatiques:</h3>
<p>Elles stockent l'état de votre système et sont gérées par PowerShell. Elles ne peuvent pas être modifiées.</p>
<p>Pour lister ces variables automatiques vous pouvez utiliser la commande:</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-Help about_automatic_variable</code></pre>
<p>Voici quelques exemples que peuvent renvoyer ces variables</p>
<figure class="image"><img src="/variable_automatique.png"></figure>
<p>La première variable indique par un booléen si la dernière commande à bien été exécutée.</p>
<p>la seconde renvoie à quel emplacement vous vous situez.</p>
<p>&nbsp;</p>
<h3>Les variables de préférences:</h3>
<p>Elles stockent la configuration de votre système et peuvent être modifiées.</p>
<p>Pour lister ces variables utilisez la commande:</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-Help about_preference_variable</code></pre>
<p>&nbsp;</p>
<p>voici une des variables de préférences les plus connues pour la gestion des erreurs que nous verrons un peu plus tard.</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">$ErrorActionPreference</code></pre>
<p>&nbsp;</p>
<p>Dans cette capture vous pouvez voir les valeurs que nous pouvons lui attribuer:</p>
<figure class="image"><img src="/erroraction.png"></figure>
<p>&nbsp;</p>
<p>Je vous invite à consulter ces variables qui peuvent être utiles dans certaines situations.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Création d'un menu sous PowerShell</h2>
<p>Voici un exemple de menu qu'il est possible de faire avec la méthode suivante :</p>
<figure class="image image_resized" style="width:58.46%;"><img src="/capture2.png"></figure>
<p>&nbsp;</p>
<h2>Principe de fonctionnement</h2>
<p>Nous avons besoin de déclarer une variable qui va servir en quelque sorte de bouton “allumé” ou “éteins” : <code>$continue = $true</code></p>
<p>Avec cette variable j'utilise une boucle pour permettre de laisser en permanence l'affichage :&nbsp;</p>
<pre><code class="language-plaintext">While ($continue)
{
	&lt;le menu avec des Write-Host&gt;
}</code></pre>
<p>Puis une seconde variable pour stocker mon choix avec <code>$choix = read-host “faire un choix”</code></p>
<p>Suivant l'état de ce choix le script sortira de la boucle <code>while</code> et cela provoquera soit une action du script soit une sortie du script avec <code>switch ($choix)</code>.</p>
<p>Le <code>switch</code> va permettre d'indexer les choix ,de les lister et d'exécuter les commandes.</p>
<p>Pour sortir du script si vous faites le choix ‘<i>x</i>’ le script passe la variable <code>$continue</code> à <code>$false</code> ce qui aura pour effet d'arrêter la boucle <code>while</code>.</p>
<p>La commande <code>default</code> permet de renvoyer un message d'avertissement si vous rentrez un choix qui n'est pas dans le menu.</p>
<p>&nbsp;</p>
<h2>Exemple</h2>
<pre><code class="language-plaintext">$continue = $true
while ($continue){
	write-host “----------------------MON TITRE -----------------------”
	write-host “1. mon action 1”
	write-host "2. mon action 2"
	write-host "x. exit"
	write-host "--------------------------------------------------------"
	$choix = read-host “faire un choix :”
	switch ($choix){
		1{commande de mon action 1}
		2{commande de mon action 2} 
		‘x’ {$continue = $false}
		default {Write-Host "Choix invalide"-ForegroundColor Red}
	}
}
	
	</code></pre>
<p>&nbsp;</p>

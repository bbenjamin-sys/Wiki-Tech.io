<!--
title: PowerShell - Les bases
description: Les bases pour bien débuter dans PowerShell
published: true
date: 2021-08-11T05:58:11.641Z
tags: 
editor: ckeditor
dateCreated: 2021-05-24T16:22:45.768Z
-->

<figure class="image image_resized" style="width:35.82%;"><img src="https://www.seekpng.com/png/full/831-8318055_february-5-windows-powershell-logo.png" alt="February 5 @ - Windows Powershell Logo | Full Size PNG Download | SeekPNG"></figure>
<h1>Les commandes ou applets de commande (cmdlet)</h1>
<p>Elles sont composées d’une paire de la forme “verbe ”-“nom” destiné à en faciliter la mémorisation.</p>
<p>exemple :</p>
<pre><code class="language-plaintext">Get-Service</code></pre>
<p>Get = verbe</p>
<p>Service = nom</p>
<p>elles peuvent être accompagnées dans certains cas de paramètres et de valeurs. Par exemple avec la commande:</p>
<pre><code class="language-plaintext">New-Item -type file -Path c:\test.txt</code></pre>
<p>New-Item = la commande</p>
<p>-type = un paramètre</p>
<p>file = une valeur</p>
<p>-Path = un paramètre</p>
<p>c:\test.txt = une valeur</p>
<p>petite astuce, vous pouvez lister tout les verbes que PowerShell utilise avec la commande <code>Get-verb</code>. faites un essai…</p>
<p>simple non?</p>
<h1>Le pipeline</h1>
<p>Le pipeline, symbolisée par le caractère “<strong>|</strong>” (<strong>AltGr</strong> + <strong>6</strong>) permet d'exécuter plusieurs commandes à la suite.</p>
<p>Exemple :&nbsp;</p>
<pre><code class="language-plaintext">Get-Process | Sort-Object CPU</code></pre>
<p>Dans ce cas précis, la commande <code>Sort-Object</code> tri les processus par utilisation de Cpu</p>
<p>&nbsp;</p>
<h1>L' aide</h1>
<p>Sous PowerShell la commande <code>Get-Help</code> permet d'afficher la fonction et des exemples d'une commande.</p>
<pre><code class="language-plaintext">Get-Help  &lt;la commande&gt;</code></pre>
<p>&nbsp;</p>
<p>Mais avant d'utiliser cette commande il faut faire une mise à jour de l'aide de PowerShell avec la commande</p>
<pre><code class="language-plaintext"> Update-Help</code></pre>
<p>&nbsp;</p>
<p>Cette commande <code>Get-Help</code> permet d'avoir une aide de manière très générale si on souhaite obtenir plus d'informations on peut ajouter l'option <code>-detailed</code></p>
<pre><code class="language-plaintext">Get-Help &lt;la commande&gt; -detailed</code></pre>
<p>&nbsp;</p>
<p>On peut aussi lister des exemples d'utilisation d'une commande avec l'option <code>-examples</code></p>
<pre><code class="language-plaintext">Get-Help &lt;la commande&gt; -examples</code></pre>
<p>&nbsp;</p>
<p>Une dernière option de <code>Get-help</code> vous permet d'afficher l'aide complète de la commande <code>-Full</code></p>
<pre><code class="language-plaintext">Get-Help &lt;la commande&gt; -Full</code></pre>
<p>Il arrive parfois que l'aide renvoyée sous PowerShell ne soit pas complète malgré un <code>Update-Help.</code></p>
<p>Pour cela il y a possibilité d'aller consulter directement l'aide en ligne avec l'option <code>-online</code>&nbsp;</p>
<pre><code class="language-plaintext">Get-Help &lt;la commande&gt; -online</code></pre>
<p>&nbsp;</p>
<p>Si vous voulez de l'aide sur la syntaxe d'une commande, PowerShell indique par “<strong>[ ]</strong>” si le paramètre est obligatoire.</p>
<p>Par exemple si vous voulez de l'aide sur la syntaxe de commande <code>Get-ChildItem</code>&nbsp;</p>
<pre><code class="language-plaintext">Get-Help Get-ChildItem</code></pre>
<p>On peut constater dans la capture que certains paramètres doivent obligatoirement comportés des valeurs. Vous pouvez également voir tout en bas les liens connexes à cette commande.</p>
<figure class="image"><img src="/get-help_gti.png"></figure>
<p>&nbsp;</p>
<p>La commande <code>Get-Help</code> permet également de rechercher une commande si, par exemple, vous souhaitez trouver une commande qui gère les services.</p>
<pre><code class="language-plaintext">Get-Help service</code></pre>
<p>Voici ce que renvoie la commande, on peut voir les commandes qui contiennent le mot service.</p>
<figure class="image"><img src="/get-help_service.png"></figure>
<p>&nbsp;</p>
<p>Une autre fonction de l'aide permet d'avoir des informations sur un sujet précis.</p>
<p>Pour lister ces sujets utilisez l'option <code>about_*</code>&nbsp;</p>
<pre><code class="language-plaintext">Get-Help about_*</code></pre>
<p>Par exemple, si vous voulez de l'aide au sujet de pipeline</p>
<pre><code class="language-plaintext">Get-Help about_pipeline</code></pre>
<p>Voici ce que renvoie la commande</p>
<figure class="image"><img src="/get-help_about.png"></figure>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>Les Alias</h1>
<p>Dans PowerShell, les alias permettent de créer des abréviations de commande. Je m'explique, vous connaissez certainement un alias que vous exécuter dans votre invite de commande. NON?</p>
<p>et <code>cd</code> c'est &nbsp;un alias de <code>change-directory</code>.</p>
<p>Et bien avec PowerShell vous avez la possibilité de les lister, les supprimer les modifier et même de les créer…</p>
<p>&nbsp;</p>
<p>Pour les lister :</p>
<pre><code class="language-plaintext">Get-Alias</code></pre>
<p>&nbsp;</p>
<figure class="image"><img src="/get-alias.png"></figure>
<p>&nbsp;</p>
<p>modifier un alias:</p>
<pre><code class="language-plaintext">Set-Alias </code></pre>
<p>&nbsp;</p>
<p>&nbsp;le créer :</p>
<pre><code class="language-plaintext">New-Alias </code></pre>
<p>&nbsp;</p>
<p>le supprimer :</p>
<pre><code class="language-plaintext">Remove-Alias</code></pre>
<p>&nbsp;</p>
<p>exporter des alias :</p>
<pre><code class="language-plaintext">Export-Alias</code></pre>
<p>&nbsp;</p>
<p>et à contrario les importer:</p>
<pre><code class="language-plaintext">Import-Alias</code></pre>
<p>&nbsp;</p>
<p>Pour paramétrer ces commandes, si vous le désirez, je vous invite à utiliser <code>Get-Help</code>.</p>
<p>A titre personnel, j'utilise très peu les alias, mais il faut en connaitre certains lorsque vous essayez de lire un script réalisé par une autre personne.</p>
<h1>Lister les méthodes et les propriétés</h1>
<p>Maintenant que nous avons vu, comment était composée une commande, le pipeline et l'aide, il est temps, comme je vous l'ai dis dans le premier chapitre, que tout était objet dans PowerShell et de découvrir plus en détail ce que sont les propriétés les méthodes. C'est à cet instant, que nous alors voir quelle commande va nous permettre de lister tout cela.</p>
<p><code>Get-Member</code> est la commande qui nous dis quels sont les propriétés et les méthodes que nous pouvons appliquer à un objet.</p>
<p>un exemple concret est plus parlant:</p>
<figure class="image"><img src="/get-member.png"></figure>
<p>(Vous remarquerez que j'utilise la commande <code>Get-Service</code>, que je récupère toutes les méthodes et propriétés en passant par une seconde commande <code>Get-Member</code> et pour enchainer ces commandes j'opte pour un pipeline)</p>
<p>C'est à partir de ces éléments qu'à présent on peut savoir quelles sont les propriétés et les méthodes d'un service.&nbsp;</p>
<p>Par exemple: Pause, Stop, Refresh sont des méthodes. Status, Servicename, ServiceType sont des propriétés.</p>
<h1>Les providers</h1>
<p>Dans PowerShell, &nbsp;les providers permettent d'accéder par exemple à la base de registre, aux fichiers système, à l'environnement etc…</p>
<ul>
  <li>Base de Registre {HKLM, HKCU}</li>
  <li>Alias {alias}</li>
  <li>Environnement {env}</li>
  <li>FileSystem {C,D,E,F}</li>
  <li>Function {Function}</li>
  <li>variable {Variable}</li>
</ul>
<p>Pour lister l'ensemble des providers, on utilise la commande</p>
<pre><code class="language-plaintext">Get-Psdrive</code></pre>
<p>L'avantage c'est que vous pouvez parcourir ces éléments comme si c'était un système de fichiers.</p>
<p>Exemple, si vous voulez parcourir la base de registre machine &nbsp;il suffit de taper <code>cd hklm:</code> et vous vous retrouvez dans la base de registre et la parcourir comme si c'était un filesystem et revenir dans votre arborescence Windows avec un <code>cd c:</code>.</p>
<figure class="image"><img src="/psdrive.png"></figure>
<p>Vous avez ensuite la possibilité de créer ou de consulter des entrées dans la base de registre comme si c'était un filesystem et utiliser les commandes de base.</p>
<p>Pour modifier la valeur d'une clé de registre ou des propriétés d'un élément je vous laisse consulter la commande</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Set-ItemProperty </code></pre>
<h1>Récupérer des informations WMI et CIM</h1>
<p>Wmi (Windows Management instrumentation),implémenté dans Windows, permet d'obtenir des informations sur un système et même à distance tel que la version du bios, le nom de la machine, le fabricant, le modèle, la date d'installation etc. Cela permet en quelques sortes d'interroger l'inventaire matériel et logiciel de votre système.&nbsp;</p>
<p>Il existe une commande pour obtenir ces informations, mais on peut également invoquer des méthodes et des propriétés avec celle-ci.</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-CimInstance</code></pre>
<p>&nbsp;</p>
<p><code><u>Get-CimInstance</u></code> est une commande, qui se base sur des instances CIM (Common Information Model ) , WS-MAN (WS-Management) et le protocole WInRM (<i>Windows Remote Management), couplé au protocole SOAP (Simple Object Acces Protocol).</i></p>
<p>Voyons comment utiliser cette commande et obtenir des infos sur un système.</p>
<p>Récupérons les information sur la mémoire vive.</p>
<figure class="image"><img src="/get-ciminstance.png"></figure>
<p>&nbsp;</p>
<p>Vous remarquez que j'utilise l'option <code>-classname</code> ? et oui, en effet, toutes les requêtes WMI et les instances CIM sont regroupées par classe. Et c'est maintenant, que je vous montre comment je fais pour m'y retrouver dans toutes ces classes.</p>
<p>C'est alors que nous vient en aide la commande <code>Get-Cimclass</code>.</p>
<p>Si on exécute cette commande on voit que la liste est longue et que cela peut paraitre un peu compliqué, à première vue, et par forcément facile à lire. De plus, la commande renvoie l'ensemble des classes Wmi et Cim.</p>
<p>&nbsp;Pour cela 3 solutions pour s'y retrouver:</p>
<ul>
  <li><u>renvoyer le tout dans un fichier texte,</u> le sauvegarder pour l'avoir sous la main puis un petit “<strong>ctrl + F”</strong> pour rechercher dans la liste.</li>
</ul>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-CimClass | Out-File -path c:\classcim.txt</code></pre>
<p>&nbsp;</p>
<ul>
  <li><u>renvoyer le tout dans un fichier Excel</u> et faire sa petite recherche à l'aide d'outils incorporés.</li>
</ul>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-Cimclass | Select-Object CimClassName | Export-Csv -Path C:\classescim.csv</code></pre>
<p>&nbsp;</p>
<p>Petite remarque: <code>Select-Object</code> permet de filtrer les informations de la commande en récupérant uniquement la partie CimclassName de <code>Get-CimClass</code></p>
<p>&nbsp;</p>
<ul>
  <li><u>renvoyer le tout dans un GridView</u>, un outil, bien utile, fourni dans PowerShell .</li>
</ul>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-Cimclass | Out-GridView</code></pre>
<p>&nbsp;</p>
<p>J'en profite pour vous montrer le Gridview. &nbsp;</p>
<figure class="image"><img src="/gridview.png"></figure>
<p>&nbsp;</p>
<p>C'est une Fenêtre, bien pratique, qui permet dans ce cas, de mettre directement sous forme de tableau, de filtrer ou de rechercher des éléments renvoyés par une commande.</p>
<p>Vous commencez certainement à vous dire POWAAA!! &nbsp;puissant le truc…</p>
<p>Connaitre à quoi servent toutes les requêtes WMI et les instances CIM serait un peu fou. C'est pourquoi, je vous renvoie vers ce <a href="https://docs.microsoft.com/fr-fr/windows/win32/cimwin32prov/cimwin32-wmi-providers">lien</a> pour en connaitre leurs utilités et en savoir un peu plus sur ces classes.</p>
<p>Allez à vous de jouer! Essayez de récupérer des infos, comme par exemple sur la version de votre bios, la date de l'installation du système, le ou les disque(s) dur etc…</p>
<h1>Les variables</h1>
<p>Une variable PowerShell est un emplacement de stockage provisoire en mémoire destiné à recueillir une valeur, un objet ou une collection d’objets.<br>Les variables sont généralement nommées, et leurs noms sont toujours précédés d’un symbole “$“<br>Les variables sont automatiquement “typées” lors de l’affectation de valeur (si elles ne sont pas déclarées au préalable.)</p>
<p>Exemple :</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">$variable = une valeur </code></pre>
<p>&nbsp;</p>
<p>Avant de rentrer dans le vif de ce sujet, il faut savoir que sous PowerShell, il existe deux type de variables spécifiques générées automatiquement.</p>
<h2>Les variables automatiques</h2>
<p>Elles stockent l'état de votre système et sont gérées par PowerShell. Elles ne peuvent pas être modifiées.</p>
<p>Pour lister ces variables automatiques vous pouvez utiliser la commande:</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-Help about_automatic_variable</code></pre>
<p>Voici quelques exemples que peuvent renvoyer ces variables</p>
<figure class="image"><img src="/variable_automatique.png"></figure>
<p>La première variable indique par un booléen si la dernière commande à bien été exécutée.</p>
<p>la seconde renvoie à quel emplacement vous vous situez.</p>
<h2>Les variables de préférences</h2>
<p>Elles stockent la configuration de votre système et peuvent être modifiées. De manière très générale, elle permettent de définir le comportement de PowerShell dans certaines situations.</p>
<p>Pour lister ces variables utilisez la commande:</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-Help about_preference_variable</code></pre>
<p>&nbsp;</p>
<p>voici une des variables de préférences les plus connues pour la gestion des erreurs que nous verrons un peu plus tard.</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">$ErrorActionPreference</code></pre>
<p>&nbsp;</p>
<p>Dans cette capture vous pouvez voir les valeurs que nous pouvons lui attribuer:</p>
<figure class="image"><img src="/erroraction.png"></figure>
<p>&nbsp;</p>
<p>Je vous invite à consulter ces variables automatiques et de préférences qui peuvent être utiles dans certaines situations.</p>
<p>&nbsp;</p>
<h2>Lister les variables</h2>
<p>&nbsp;</p>
<p>Pour lister l'ensemble des variables sur PowerShell, il existe la commande :</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Get-Variable</code></pre>
<p>&nbsp;</p>
<figure class="image"><img src="/get-variable.png"></figure>
<p>&nbsp;</p>
<p>Vous comprenez, à présent pourquoi je vous ai parlé des variables automatiques et de préférences avant. En effet, la commande <code>Get-Variable</code> vous les liste toutes par noms et indique quelle(s) valeur(s) est stockée(s).Je met volontairement un “(s)” car elles peuvent parfois en contenir plusieurs. Lorsque nous verrons comment créer nos propres variables, elles viendront s'ajouter à cette liste.</p>
<h2>Manipulation des variables</h2>
<p>Comme je vous l'ai indiqué en début de chapitre une variable se déclare par le sigle <strong>$ </strong>suivit de son <strong>nom</strong> &nbsp;puis vous pouvez lui affecter une <strong>valeu</strong>r avec le signe <strong>égal</strong>.</p>
<p>A partir de cet état, il est possible de lui apporter des modifications de manière automatique via PowerShell.</p>
<p>Prenons, par exemple cette variable</p>
<pre><code class="language-plaintext">$Unmot = papamica</code></pre>
<p>Il y a possibilité sous PowerShell d'appliquer une méthode à cette variable. Par exemple, je peux demander à PowerShell de stocker le mot <code>papamica</code> en majuscule. Pour ce faire, vous déclarez votre variable, puis faites appel à celle-ci par <strong>$nom et ajouter un point</strong> et lister l'ensemble des méthodes et propriétés de celle-ci.</p>
<p>Un exemple est plus parlant sous Visual Studio Code:</p>
<figure class="image"><img src="/variable_manip.png"></figure>
<p>&nbsp;</p>
<p>On peut voir que Visual Studio Code nous renvoie toutes les méthodes et propriétés que je peux appliquer à une variable.</p>
<p>Si vous voulez mettre la valeur de votre variable en majuscule il me suffit de choisir <code>.ToUpper()</code>.</p>
<figure class="image"><img src="/variable_manip2.png"></figure>
<p>&nbsp;</p>
<p>Remarque: Sur la première ligne, vous constaterez que j'utilise <strong>“ " </strong>pour que PowerShell considère les éléments qui se trouve à l'intérieur comme une chaine de caractères. Sur la seconde ligne, j'écris <code>$unnom</code> pour que la valeur de ma variable s'affiche dans le prompt qui se trouve dans la fenêtre du bas.</p>
<p>Vous pouvez également utiliser <code>Get-Member</code> pour lister les méthodes et propriétés d'une variable avec:</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">$mavariable | Get-Member </code></pre>
<p>&nbsp;</p>
<p>Un autre exemple:&nbsp;</p>
<p>Vous pouvez également remplacer une lettre voir une partie de votre valeur avec <code>.Replace()</code>.On constate, que certaines méthodes demandent des arguments dans les “<strong>()</strong>”.</p>
<figure class="image"><img src="/variable_replace.png"></figure>
<p>&nbsp;</p>
<p>allez un dernier pour la route, on peut savoir à quel type de variable nous avons à faire avec <code>.Gettype()</code></p>
<figure class="image"><img src="/variable_gettype.png"></figure>
<h2>La concaténation</h2>
<p>On appelle la concaténation le fait de pouvoir associer ou grouper des caractères en une chaine. Par Exemple, si on souhaite intégrer la valeur d'une variable dans du texte.&nbsp;</p>
<p>Déclarons une variable <strong>$mot</strong>, on lui ajoute une valeur, puis jouons &nbsp;avec les commandes <code>Write-Host</code> (qui permet de renvoyer une chaine de caractères dans le prompt) et &nbsp;<code>Read-Host</code>(qui attends que l'on entre une valeur dans le prompt) pour concaténer.&nbsp;</p>
<p>Voyons ce que cela donne avec <code>Write-Host</code></p>
<p>&nbsp;</p>
<figure class="image"><img src="/conca_write.png"></figure>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>On voit que l'analyse de <code>Write-Host</code> va récupérer la valeur de <code>$mot</code> et l'intégrer dans la chaine de caractère <strong>“j'apprends”.</strong></p>
<p>Essayons maintenant avec <code>Read-Host</code> .</p>
<p>&nbsp;</p>
<figure class="image"><img src="/read-host_good.png"></figure>
<p>&nbsp;</p>
<p>Vous remarquez que <code>$mot = Read-Host</code> attends et ensuite va stocker ce que vous écrivez dans le prompt. On peut ensuite le concaténer.</p>
<p>Je reviens un instant sur un cas particulier lorsque vous faites appel à une propriété ou une méthode de variable il y a une syntaxe un peux spécifique pour la concaténer.</p>
<p>deux solutions, à vous de choisir il n'y a pas forcement de règle puisqu'il n'y pas une seule et unique façon d'écrire un script :</p>
<figure class="image"><img src="/read-host.png"></figure>
<p>Ici on stocke la variable demandée dans le prompt avec <code>Read-host</code> puis &nbsp;appliquer une transformation à la variable avec <code>$mot = $mot.ToUpper()</code> en la réaffectant</p>
<p>il suffit de faire un simple concaténation pour obtenir le résultat voulu.&nbsp;</p>
<p>l'autre méthode c'est :&nbsp;</p>
<p>&nbsp;</p>
<figure class="image"><img src="/toupperr-2.png"></figure>
<p>Dans ce cas, on applique en même temps la transformation de la chaine de caractère &nbsp;contenu dans la variable <code>$mot</code>, en stipulant de récupérer la valeur dans <code>$mot</code> avec <strong>$ puis les parenthèses</strong> et d'appliquer la transformation avec <code>$mot.ToUpper()</code> à la variable <code>$mot</code>.</p>
<p>&nbsp;</p>
<h2>Le Here-string</h2>
<p>Le <code>Here-String</code> permet de mettre du texte en forme et de la conserver.</p>
<p>Voici la syntaxe du <code>Here-String</code>:</p>
<pre><code class="language-plaintext">$texte=@"
&lt;montexte&gt;
"@</code></pre>
<p>Voici un exemple de ce que l'on peut faire avec:</p>
<figure class="image"><img src="/here-string.png"></figure>
<p>&nbsp;</p>
<p>On peut également utiliser la concaténation à l'intérieur du <code>Here-String</code></p>
<figure class="image"><img src="/here-string2.png"></figure>
<h2>La portée des variables</h2>
<p>&nbsp;</p>
<p>Lorsque vous démarrer PowerShell, &nbsp;les variables sont hiérarchisées suivant le schéma Parent - Enfant. C'est à dire que les variables de la portée enfant ne pourront être employées dans la portée Parent. Un schéma pour vous illustrez tout ça :</p>
<figure class="image"><img src="/portée_variable.png"></figure>
<p>&nbsp;</p>
<p>Mettons en pratique pour analyser ce qu'il se passe.</p>
<figure class="image"><img src="/portee.png"></figure>
<p>Dans cette exemple, nous utilisons une fonction que nous verrons plus tard. Dans le bloc de script symbolisé par <strong>{}</strong> la variable <code>$portee</code> est bien lu par la fonction. Hors, à la ligne 8 le <code>Write-Host</code> ne peut pas lire cette variable. La variable <code>$portee</code> se limite aux <strong>{} </strong>.</p>
<p>Pour palier à ce soucis, on va indiquer à PowerShell que <code>$portee</code> est une variable dite globale par <code>$global:portee</code></p>
<p>voici ce que cela donne:</p>
<figure class="image"><img src="/global.png"></figure>
<p>&nbsp;</p>
<h2>La variable de pipeline</h2>
<p>&nbsp;</p>
<p>La variable de pipeline <code>$_</code>est une variable un peu spécifique puisque celle-ci s'utilise derrière un pipeline. Pour illustrer son utilisation, nous allons récupérer tout les services avec <code>Get-Service</code> et filtrer avec <code>Where-Object</code> uniquement ceux qui sont stoppés.&nbsp;</p>
<figure class="image"><img src="/variable_pipeline.png"></figure>
<p>la variable <code>$_.</code> récupère les méthodes et propriétés renvoyées par la commande <code>Get-Service</code> à travers le pipeline.</p>
<p>remarque : nous avons utilisé <code>-eq</code> qui est un opérateur de comparaison qui signifie égal à.</p>
<h1>Commande à distance</h1>
<p>Avec PowerShell, vous aurez certainement remarquer que la majeur partie des commande comporte l'option <code>-Computername</code>. Cette option a pour avantage de transmettre une instruction à une autre machine. Hors, il apparait dans certains cas que cette option n'existe pas. C'est pour cela, qu'il est tout à fait possible d'utiliser des commandes pour gérer le comportement ou de donner des instructions à une machine distante.&nbsp;</p>
<p>C'est ce que nous allons voir dans plusieurs façons différentes de procéder. Par l'utilisation de la commande <code>Invoke-Commande</code>, par l'ouverture d'une session à distance et ensuite nous verrons comment utiliser PowerShell Direct pour gérer vos machines virtuelles.</p>
<h2>Exécuter une commande à distance</h2>
<p>&nbsp;</p>
<p>Pour exécuter une commande à distance, nous allons utiliser :</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Invoke-Commande</code></pre>
<p>&nbsp;</p>
<p>Cette commande a la particularité d'utiliser le protocole Winrm et https ou http sur les ports TCP 5986 et 5985 . La déclaration de vos instructions se font dans un bloc de scripts à l'intérieure d'accolades <strong>{}</strong>.</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Invoke-Command  -Computername “nom de la machine cible” { vos instructions à la machine cible}</code></pre>
<p>&nbsp;</p>
<p>Pour que vos machines cibles puissent autoriser l'utilisation des commandes à distance, vous devez au préalable donner une autorisation par la commande</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Enable-PSRemoting</code></pre>
<p>&nbsp;</p>
<h3>Commande à distance hors domaine</h3>
<p>Si vos machines ne sont pas dans un domaine ou de domaines différents vous devrez en plus ajouter les machines dans le fichier TrustedHosts par la commande :</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Set-Item WsMan:\Localhost\client\TrustedHosts -value "ip ou noms des machines" </code></pre>
<p>&nbsp;</p>
<p>remarque : la valeur de l'option <code>-value</code> peut être un nom de machine, une IP ou * mais cela n'est pas recommandé pour des raisons de sécurité.</p>
<p>Puis vérifiez que vos machines peuvent utiliser les commandes à distance :</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Test-WsMan "ip ou nom des machines "</code></pre>
<p>&nbsp;</p>
<p>voici un exemple d'utilisation hors domaine où on stocke les valeurs dans une variable les éléments d'un <code>Invoke-Command </code>:</p>
<figure class="image"><img src="/invoke_commande.png"></figure>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Commande à distance dans un domaine</h2>
<p>Dans un domaine, la procédure est un peu plus simple, puisque vous êtes dans un environnement un peu plus “sécurisé ”.Si vous souhaitez exécuter des commandes sur une machine ou plusieurs machines distantes, vous devez uniquement activer le service winrm sur chacune d'elles par la commande :</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Enable-PSRemoting</code></pre>
<p>&nbsp;</p>
<p>Ensuite depuis la machine maitre vous pouvez exécuter des commande à distance via un <code>Invoke-Command</code> que nous avons vu précédemment.</p>
<p>Voici un exemple où je demande à un serveur AD, les services qui sont dans l'état démarré :</p>
<figure class="image"><img src="/invokead.png"></figure>
<h2>Session à distance</h2>
<p>L'autre possibilité sous PowerShell est d'utiliser des sessions à distance. Vous allez, en quelques sortes, vous connecter dans le prompt d'une machine distante. L'avantage c'est que vous allez établir une connexion persistante…. cela est pratique quand vous avez besoin de passer d'une machine à l'autre , d'avoir à utiliser des commandes spécifiques à une situation bien déterminée ou lorsque vous avez besoins de faire appel à cette machine de façon aléatoire.&nbsp;</p>
<p>Auparavant, vous aurez autorisé le service winrm avec un <code>Enable-PSRemoting</code> sur votre machine distante.</p>
<p>Ensuite nous allons ouvrir une session via la commande:</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">New-PSSession</code></pre>
<p>&nbsp;</p>
<p>Mais pour faire appel à chaque fois que vous le désirez à cette session, il y a la possibilité de la stocker dans une variable et d'entrer dans celle-ci avec <code>Enter-PSSession</code> quand vous le souhaitez:</p>
<p>voici un exemple illustrant cette utilisation:</p>
<p>&nbsp;</p>
<figure class="image"><img src="/enter-psession.png"></figure>
<p>&nbsp;</p>
<p>Vous remarquerez dans le prompt que je suis bien connecté à la machine distante ici "AD" et que je peux taper les commandes que je souhaites comme si j'étais directement dans son prompt.</p>
<p>Pour sortir de cette pseudo connexion, tapez <code>exit</code> dans le prompt.</p>
<p>Cependant, gardez à l'esprit que la session reste active, et que pour des soucis de sécurité, il faudra bien évidement fermer toutes ces sessions actives, si il n'est pas nécessaire de les garder dans cette état.</p>
<p>Avec la commande <code>Get-PSSession</code>, vous pouvez consulter les sessions toujours actives.</p>
<figure class="image"><img src="/get-psession.png"></figure>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Pour revenir à un état dit sécurisé, vous devez désactiver ces sessions, si il n'est pas nécessaire de les laisser actives, ainsi que le service winrm.</p>
<p>pour désactiver ces sessions, vous pouvez utilisez les id de sessions ou via les arguments que vous souhaitez, à vous de les consulter dans la commande <code>Remove-PSSession</code>&nbsp;</p>
<figure class="image"><img src="/remove-psession.png"></figure>
<p>&nbsp;Pour terminer, vous pouvez aussi désactiver le service winrm avec <code>Disable-PSRemoting</code></p>
<p>&nbsp;</p>
<h1>PowerShell Direct</h1>
<p>&nbsp;</p>
<p>Si vous souhaitez travailler sur un environnement virtualisé, vous avez la possibilité, à partir de Windows 10 et Hyper-v 2016, de pouvoir gérer vos VMs depuis votre hôte dans PowerShell.</p>
<p>Pour cela, vos VMs devront être dans l'état démarré et vous devrez être connecté avec le compte administrateur Hyper-v ou avoir les autorisations.</p>
<p>Pour réaliser cette manipulation vous pouvez utiliser les commandes à distance que nous avons vu dans le chapitre précédent.</p>
<p>Au préalable, vous aurez besoin soit des noms de VMs , soit leurs numéros ID.</p>
<p>Pour obtenir ces informations, vous aurez besoin d'utiliser <code>Get-VM</code> et de filtrer le résultat.</p>
<figure class="image"><img src="/get-vm.png"></figure>
<p>A présent voici un exemple où nous allons rechercher des logs dans une VM avec <code>Invoke-Command</code>.</p>
<figure class="image"><img src="/directevent.png"></figure>
<p>&nbsp;</p>
<p>Autre exemple, avec l'ouverture d'une session avec <code>New-PSSession</code> et interagir dans le prompt de votre VM.</p>
<figure class="image"><img src="/sessionvm.png"></figure>
<p>&nbsp;</p>
<p>On peut constater dans les deux cas que le login est demandé à chaque connexion.</p>
<p>Un autre avantage de PowerShell direct est que vous avez la possibilité de copier un fichier de l'hôte vers une VM. Pour cela on utilise&nbsp;</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">Copy-VMFile</code></pre>
<p>&nbsp;</p>
<p>Vous devez vous assurer, avant que “les service d'invité” soit activé sur votre VM dans les paramètres de votre VM.</p>
<figure class="image"><img src="/hyper-v.png"></figure>
<p>&nbsp;</p>
<p>Voici la commande PowerShell, pour contrôler celle-ci.</p>
<figure class="image"><img src="/get-vmintegration.png"></figure>
<p>Pour l'activer,&nbsp;</p>
<figure class="image"><img src="/enable-vmintegration.png"></figure>
<p>A présent nous pouvons copier un fichier de l'hôte vers une VM.</p>
<figure class="image"><img src="/copy-vmfile.png"></figure>
